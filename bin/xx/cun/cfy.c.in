#include <oraccsys.h>
#include <setjmp.h>
#include <signal.h>
#include <locale.h>

#include <runexpat.h>
#include <xmlify.h>
#include <xpd.h>

#include "oracclocale.h"

#include "cfy.h"

static char *crashbuf;
static void signals(int argc, char **argv);

extern void cfyset_debug(int debug_flag);
extern void gdlset_debug(int debug_flag);

Cfy cfy;

/* The default is to generate outputs into the P4 cache; if -b is
   specified outputs are generated into the PQX-dir where the xtf
   lives */
int buildmode = 0;
int config_and_exit = 0;
int force = 0; /* default is not to remake if the output already exists */
int trace = 0;
int verbose = 0;

const char *arg_lig_file;
Hash **arg_ligs;
const char *html_css;
const char *invoke;
const char *infile;
const char *outfile;
const char *p4htmld;
const char *period;
const char *qfile;
const char *translation;

char *inpath, *outpath, *htmlpath;

jmp_buf done;

int stdin_xtf;

static void
show_vars(void)
{
  fprintf(stderr, "cfy variables:\n");
  fprintf(stderr, "\tinput-arg: %s\n", qfile ? qfile : infile);
  fprintf(stderr, "\tinput-path: %s\n", inpath);
  fprintf(stderr, "\toutput-path: %s\n", outpath);
}

static void
cfy_init(void)
{
  cfy.p = pool_init();
  cfy.hp = hpool_init();
  cfy.hclasses = hash_create(32);
  cfy.hconfigs = hash_create(32);
  cfy.hfonts = hash_create(8);
  cfy.m_cfg = memo_init(sizeof(Cfg), 16);
  cfy.m_class = memo_init(sizeof(Class), 16);
  cfy.m_fnt = memo_init(sizeof(Fnt), 16);
  cfy.m_line = memo_init(sizeof(Line), 256);
  cfy.m_cell = memo_init(sizeof(Cell), 256);
  cfy.m_elt = memo_init(sizeof(Elt), 1024);
  cfy.m_eltline = memo_init(sizeof(Eltline), 256);
  cfy.m_div = memo_init(sizeof(Div), 256);
  cfy.m_heading = memo_init(sizeof(Heading), 16);

  /*cfy.body = list_create(LIST_SINGLE);*/
  cfy_reader_init();
  cfy.o = stdout;
  cfy.pqx = "X000000";
  curr_cp->fntp = cfy_class_fnt(&cfy, curr_cp);
  cfy.c = curr_cp;
  cfy.key = cfy.c->key;
  cfy.fnt = cfy.c->fnt;
  
  mesg_init();
  mloc_init();

#if 0
  /* use an arg key instead */
  if (arg_lig_file)
    {
      cfy.c->lig = cfy_lig_load(arg_lig_file);
      hash_add(cfy.hfonts, (uccp)cfy.c->fnt, cfy.c);
    }
#endif
  
  espaces[ELT_C] = espaces[ELT_W] = espaces[ELT_J] = espaces[ELT_N] = espaces[ELT_F] = 1;
}

static void
cfy_term(void)
{
  pool_term(cfy.p);
  hpool_term(cfy.hp);
  hash_free(cfy.hclasses, NULL);
  hash_free(cfy.hfonts, NULL);
  memo_term(cfy.m_class);
  memo_term(cfy.m_elt);
  /*free(cfy.elt_lines);*/ /* this one is calloc'ed */
  memo_term(cfy.m_eltline);
  memo_term(cfy.m_cell);
  memo_term(cfy.m_line);

  mloc_term();
  mesg_term();
}

static void
cfy_post_div(Cfy *c, Div *dp)
{
  /* Flatten the list of lists into an array of arrays */
  dp->elt_lines = calloc(list_len(dp->lines)+1, sizeof(Eltline*));
  
  int i;
  List *lp;
  for (i = 0, lp = list_first(dp->lines); lp; ++i, lp = list_next(dp->lines))
    {
      dp->elt_lines[i] = memo_new(c->m_eltline);
      dp->elt_lines[i]->epp = (Elt**)list2array_c(lp, &dp->elt_lines[i]->len);
    }
  dp->elt_lines[i] = NULL;
  
  for (i = 0; dp->elt_lines[i]; ++i)
    {
      if (c->cfg && c->cfg->hsubkeys)
	cfy_subbings(c, dp->elt_lines[i]);
      /* N.B.: must do ligs before charspace */
      cfy_ligatures(c, dp->elt_lines[i]->epp);
      if (ELT_Jcs == c->c->justify || ELT_Jcp == c->c->justify)
	cfy_charspace(c, dp->elt_lines[i]);
      cfy_breakage(c, dp->elt_lines[i]->epp);
    }
}

static void
cfy_post(Cfy *c)
{
  Div *dp;
  for (dp = list_first(c->divs_with_lines); dp; dp = list_next(c->divs_with_lines))
    cfy_post_div(c, dp);
}

int
main(int argc, char **argv)
{
  setlocale (LC_ALL, ORACC_LOCALE);
  signals(argc, argv);
  cfy.o = stdout;
  options(argc, argv, "bC:c:fH:hi:l:no:P:p:q:sTt:U:uvw");

  if (verbose > 2)
    cfyset_debug(1);
  else
    cfyset_debug(0);
  gdlset_debug(0);
  
  cfy_init();

  if (cfy.arg_ccf)
    {
      if (cfy_cfg_load(&cfy, cfy.arg_ccf))
	{
	}
      else if (config_and_exit)
	exit(0);
    }
  
  if (period)
    {
      char xperiod[strlen(period)+1], *t;
      strcpy(xperiod,period);
      for (t = xperiod; *t; ++t)
	if ('_' == *t)
	  *t = ' ';
      struct perfnt *pfp = perfnt(xperiod, strlen(xperiod));
      if (pfp)
	cfy.period_ccf = pfp->ccf;
    }

  if (!infile && argv[optind])
    infile = argv[optind++];

  const char **f = calloc(2, sizeof(char*));

  if (infile || qfile)
    {
      if (cfy.weboutput)
	{
	  if (!p4htmld)
	    {
	      const char *p4cache = getenv("ORACC_P4_CACHE");
	      if (p4cache)
		{
		  p4htmld = malloc(strlen(p4cache)+5);
		  sprintf((char*)p4htmld, "%s/htm", p4cache);
		}
	      else
		p4htmld = "@@ORACC@@/www/p4.d/htm";
	    }
	}
      if (qfile)
	{
	  cfy.project = strdup(qfile);
	  char *colon = strchr(cfy.project, ':');
	  if (colon)
	    *colon = '\0';
	  else
	    {
	      fprintf(stderr, "cfy: must give project:PQX when using -q option. Stop.\n");
	      exit(1);
	    }
	  file_args(p4htmld, qfile, "xtf", outfile, "cfy", NULL, &inpath, &outpath, &htmlpath);
	  f[0] = inpath;
	}
      else if (infile)
	{
	  inpath = strdup(infile);
	  f[0] = inpath;
	  if (outfile)
	    outpath = strdup(outfile);
	}
    }

  if (!f[0] && !stdin_xtf)
    {
      fprintf(stderr, "cfy: nothing to cuneify. Stop.\n");
      exit(1);
    }

  cfy.infile = f[0];
  
  if (cfy.project)
    {
      cfy.xpd = xpd_init(cfy.project, cfy.p);
      const char *cfyccf = xpd_option(cfy.xpd, "cfy-ccf");
      if (cfyccf)
	cfy.project_ccf = (ccp)pool_copy((uccp)cfyccf, cfy.p);
    }
  
  if (verbose > 1)
    show_vars();

  cfy_lgs(&cfy);
  
  if (!cfy.no_output)
    {
      if (f[0] && !access(f[0], R_OK))
	{
	  if (outpath && strcmp(outpath, "-"))
	    {
	      if (!(cfy.o = fopen(outpath, "w")))
		{
		  fprintf(stderr, "cfy: unable to write to outpath %s: %s\n",
			  outpath, strerror(errno));
		  exit(1);
		}
	    }
	}
      nodeh_register(treexml_o_handlers, NS_CFY, treexml_o_cfy);
      nodeh_register(treexml_c_handlers, NS_CFY, treexml_c_cfy);
    }
  else
    {
      if (!freopen("/dev/null", "w", stdout))
	{
	  perror("Failed to redirect stdout");
	  return EXIT_FAILURE;
	}
    }
  
  runexpat_omit_rp_wrap();
  cfy_cfg_run(&cfy);
  if (!setjmp(done))
    runexpatuD(stdin_xtf ? i_stdin : i_list, f, cfy_sH, cfy_eH, &cfy);

  cfy_post(&cfy);

  if (verbose)
    {
      cfy_body_debug(&cfy);
      exit(1);
    }
  
  if (cfy.html)
    cfy_render(&cfy, "html");
  else
    cfy_render(&cfy, "xml");
  
  cfy_term();
}

int
opts(int opt, const char *arg)
{
  switch (opt)
    {
    case 'B':
      buildmode = 1;
      break;
    case 'b':
      cfy.html = cfy.bare = 1;      
      break;
    case 'C':
      config_and_exit = 1;
    case 'c':
      cfy.arg_ccf = arg;
      break;
    case 'f':
      force = 1;
      break;
    case 'H':
      html_css = arg;
      /*falls through*/
    case 'h':
      cfy.html = 1;
      break;
    case 'i':
      infile = arg;
      break;
    case 'k':
      cfy.key = arg;
      break;
#if 0
    case 'l':
      arg_lig_file = arg;
      break;
#endif
    case 'n':
      cfy.no_output = 1;
      break;
    case 'o':
      outfile = arg;
      break;
    case 'P':
      period = arg;
      break;
    case 'p':
      cfy.project = arg;
      break;
    case 'q':
      qfile = arg;
      break;
    case 's':
      stdin_xtf = 1;
      break;
    case 't':
      translation = arg;
      break;
    case 'T':
      trace = 1;
      break;
    case 'U':
      cfy.no_output = 1;
      cfy.coverage = 1;
      cfy.cov_list = arg;
      break;
    case 'u':
      ++cfy.coverage;
      break;
    case 'v':
      ++verbose;
      break;
    case 'w':
      cfy.weboutput = 1;
      cfy.html = 1;
      break;
    default:
      fprintf(stderr, "%s: unknown option -%c\n", invoke, opt);
      return 1;
    }
  return 0;
}

void help(void) { }

static void 
clean_exit_on_sig(int sig_num)
{
  (void)write(STDERR_FILENO, crashbuf, strlen(crashbuf));
  exit(128+sig_num);
}

static void
signals(int argc, char **argv)
{
  int i, len;
  for (i = len = 0; i < argc; ++i)
    len += strlen(argv[i]);
  crashbuf = malloc(len + argc + 128);
  strcpy(crashbuf, "cfy: emergency stop, program crash. Invoked as:\n\t");
  for (i = 0; i < argc; ++i)
    {
      if (i)
        strcat(crashbuf, " ");
      strcat(crashbuf, argv[i]);
    }
  strcat(crashbuf, "\n");
  signal(SIGINT  , clean_exit_on_sig);
  signal(SIGABRT , clean_exit_on_sig);
  signal(SIGILL  , clean_exit_on_sig);
  signal(SIGFPE  , clean_exit_on_sig);
  signal(SIGSEGV , clean_exit_on_sig);
  signal(SIGTERM , clean_exit_on_sig);
}
