#include <oraccsys.h>
#include <xmlify.h>
#include <setjmp.h>
#include "runexpat.h"
#include "cfy.h"

extern void cfyset_debug (int debug_flag);
extern void gdlset_debug (int debug_flag);

Cfy cfy;

/* The default is to generate outputs into the P4 cache; if -b is
   specified outputs are generated into the PQX-dir where the xtf
   lives */
int buildmode = 0;
int config_and_exit = 0;
int force = 0; /* default is not to remake if the output already exists */
int no_output = 0;
int trace = 0;
int verbose = 0;

const char *arg_lig_file;
Hash **arg_ligs;
const char *invoke;
const char *infile;
const char *outfile;
const char *p4htmld;
const char *period;
const char *qfile;
const char *translation;

char *inpath, *outpath, *htmlpath;

jmp_buf done;

extern int options(int, char*const*,const char*);
extern int optind;

static void
show_vars(void)
{
  fprintf(stderr, "cfy variables:\n");
  fprintf(stderr, "\tinput-arg: %s\n", qfile ? qfile : infile);
  fprintf(stderr, "\tinput-path: %s\n", inpath);
  fprintf(stderr, "\toutput-path: %s\n", outpath);
}

static void
cfy_init(void)
{
  cfy.p = pool_init();
  cfy.hp = hpool_init();
  cfy.hclasses = hash_create(32);
  cfy.hfonts = hash_create(8);
  cfy.m_assignment = memo_init(sizeof(Assignment), 16);
  cfy.m_class = memo_init(sizeof(Class), 16);
  cfy.m_line = memo_init(sizeof(Line), 256);
  cfy.m_cell = memo_init(sizeof(Cell), 256);
  cfy.m_elt = memo_init(sizeof(Elt), 1024);
  cfy.m_eltline = memo_init(sizeof(Elt), 256);
  cfy.body = list_create(LIST_SINGLE);
  cfy_reader_init();
  cfy.o = stdout;
  cfy.pqx = "X000000";
  cfy.c = curr_cp;
  cfy.key = cfy.c->key;
  cfy.fnt = cfy.c->fnt;

  mesg_init();
  mloc_init();
  
  if (arg_lig_file)
    {
      cfy.c->lig = cfy_lig_load(arg_lig_file);
      hash_add(cfy.hfonts, (uccp)cfy.c->fnt, cfy.c);
    }

  espaces[ELT_C] = espaces[ELT_W] = espaces[ELT_J] = espaces[ELT_N] = espaces[ELT_F] = 1;
}

static void
cfy_term(void)
{
  pool_term(cfy.p);
  hpool_term(cfy.hp);
  hash_free(cfy.hclasses, NULL);
  hash_free(cfy.hfonts, NULL);
  memo_term(cfy.m_assignment);
  memo_term(cfy.m_class);
  memo_term(cfy.m_elt);
  free(cfy.elt_lines); /* this one is calloc'ed */
  memo_term(cfy.m_eltline);
  memo_term(cfy.m_cell);
  memo_term(cfy.m_line);

  mloc_term();
  mesg_term();
}

static void
cfy_post(Cfy *c)
{
  /* Flatten the list of lists into an array of arrays */
  c->elt_lines = calloc(list_len(c->body)+1, sizeof(Eltline*));
  
  int i;
  List *lp;
  for (i = 0, lp = list_first(c->body); lp; ++i, lp = list_next(c->body))
    {
      c->elt_lines[i] = memo_new(c->m_eltline);
      c->elt_lines[i]->epp = (Elt**)list2array_c(lp, &c->elt_lines[i]->len);
    }
  c->elt_lines[i] = NULL;
  
  for (i = 0; c->elt_lines[i]; ++i)
    {
      cfy_subbings(c, c->elt_lines[i]);
      cfy_ligatures(c, c->elt_lines[i]->epp);
      cfy_breakage(c, c->elt_lines[i]->epp);
    }
}

int
main(int argc, char **argv)
{  
  cfy.o = stdout;
  options(argc, argv, "bC:c:fhi:l:no:p:P:q:st:Tvw");

  cfyset_debug(verbose);
  gdlset_debug(0);
  
  cfy_init();

  if (cfy.config)
    {
      if (cfy_cfg_load(&cfy, cfy.config))
	{
	  extern int cfylineno;
	  mesg_warning(cfy.config, cfylineno,
		       "cfy exiting because of configuration errors.");
	  mesg_print(stderr);	
	  exit(1);
	}
      else if (config_and_exit)
	exit(0);
    }
  
  if (period)
    {
      char xperiod[strlen(period)+1], *t;
      strcpy(xperiod,period);
      for (t = xperiod; *t; ++t)
	if ('_' == *t)
	  *t = ' ';
      struct perfnt *pfp = perfnt(xperiod, strlen(xperiod));
      if (pfp)
	cfy.fnt = pfp->fnt;
    }

  if (!infile && argv[optind])
    infile = argv[optind++];

  const char **f = calloc(2, sizeof(char*));

  if (infile || qfile)
    {
      if (cfy.weboutput)
	{
	  if (!p4htmld)
	    {
	      const char *p4cache = getenv("ORACC_P4_CACHE");
	      if (p4cache)
		{
		  p4htmld = malloc(strlen(p4cache)+5);
		  sprintf((char*)p4htmld, "%s/htm", p4cache);
		}
	      else
		p4htmld = "@@ORACC@@/www/p4.d/htm";
	    }
	}
      if (qfile)
	{
	  cfy.project = strdup(qfile);
	  char *colon = strchr(cfy.project, ':');
	  if (colon)
	    *colon = '\0';
	  else
	    {
	      fprintf(stderr, "cfy: must give project:PQX when using -q option. Stop.\n");
	      exit(1);
	    }
	  file_args(p4htmld, qfile, "xtf", outfile, "cfy", NULL, &inpath, &outpath, &htmlpath);
	  f[0] = inpath;
	}
      else if (infile)
	{
	  inpath = strdup(infile);
	  f[0] = inpath;
	  if (outfile)
	    outpath = strdup(outfile);
	}
    }

  if (!f[0])
    {
      fprintf(stderr, "cfy: nothing to cuneify. Stop.\n");
      exit(1);
    }

  if (cfy.project)
    {
      cfy.xpd = xpd_init(cfy.project, cfy.p);
      const char *cfykey = xpd_option(cfy.xpd, "cfy-key");
      if (cfykey && !(cfy.class = cfy_class(cfykey,NULL)))
	{
	  fprintf(stderr, "cfy: errors in config key %s. Stop.\n", cfykey);
	  exit(1);
	}
    }
  
  if (verbose)
    show_vars();

  if (!no_output)
    {
      if (f[0] && !access(f[0], R_OK))
	{
	  if (outpath && strcmp(outpath, "-"))
	    {
	      if (!(cfy.o = fopen(outpath, "w")))
		{
		  fprintf(stderr, "cfy: unable to write to outpath %s: %s\n",
			  outpath, strerror(errno));
		  exit(1);
		}
	    }
	}
    }
  
  runexpat_omit_rp_wrap();
  if (!setjmp(done))
    runexpatuD(i_list, f, cfy_sH, cfy_eH, &cfy);

  cfy_post(&cfy);
  
  if (!no_output)
    {
      if (cfy.html)
	cfy_render(&cfy, "html");
      else
	cfy_render(&cfy, "xml");
    }
  
  cfy_term();
}

int
opts(int opt, const char *arg)
{
  switch (opt)
    {
    case 'b':
      buildmode = 1;
      break;
    case 'C':
      config_and_exit = 1;
    case 'c':
      cfy.config = arg;
      break;
    case 'f':
      force = 1;
      break;
    case 'h':
      cfy.html = 1;
      break;
    case 'i':
      infile = arg;
      break;
    case 'k':
      cfy.key = arg;
      break;
    case 'l':
      arg_lig_file = arg;
      break;
    case 'n':
      no_output = 1;
      break;
    case 'o':
      outfile = arg;
      break;
    case 'P':
      period = arg;
      break;
    case 'p':
      cfy.project = arg;
      break;
    case 'q':
      qfile = arg;
      break;
    case 't':
      translation = arg;
      break;
    case 'T':
      trace = 1;
      break;
    case 'v':
      verbose = 1;
      break;
    case 'w':
      cfy.weboutput = 1;
      cfy.html = 1;
      break;
    default:
      fprintf(stderr, "%s: unknown option -%c\n", invoke, opt);
      return 1;
    }
  return 0;
}

void help(void) { }
